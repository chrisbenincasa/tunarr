import schedule from 'node-schedule';
import { withDb } from '../dao/dataSource.js';
import { Task } from '../tasks/task.js';
import { Maybe } from '../types.js';
import { logger } from './scheduler.js';

export type TaskFactoryFn<T> = () => Task<T>;

type ScheduledTaskOptions = {
  visible?: boolean;
  runOnSchedule?: boolean;
  runAtStartup?: boolean;
};

export class ScheduledTask<OutType = unknown> {
  #factory: TaskFactoryFn<OutType>;
  #scheduledJob: schedule.Job;
  #running: boolean = false;
  #schedule: string;

  public runAtStartup = false;
  public visible: boolean = true;
  public lastExecution?: Date;

  constructor(
    jobName: string,
    cronSchedule: string,
    taskFactory: TaskFactoryFn<OutType>,
    options?: ScheduledTaskOptions,
  ) {
    this.#schedule = cronSchedule;
    this.#factory = taskFactory;
    this.#scheduledJob = schedule.scheduleJob(jobName, cronSchedule, () =>
      this.jobInternal(),
    );

    this.visible = options?.visible ?? true;

    if (options?.runOnSchedule) {
      this.runNow(true).catch(console.error);
    }

    if (options?.runAtStartup) {
      this.runAtStartup = options.runAtStartup;
    }
  }

  get name() {
    return this.#scheduledJob.name;
  }

  running() {
    return this.#running;
  }

  // Runs an instance of this task now, cancels the next invocation
  // and reschedules the job on the original schedule.
  // If background=true, this function will not return the underlying
  // Promise generated by the running job and all errors will be swallowed.
  async runNow(background: boolean = true) {
    this.#scheduledJob.cancelNext(false);
    const rescheduleCb = () => this.#scheduledJob.reschedule(this.#schedule);
    if (background) {
      return new Promise<Maybe<OutType>>((resolve, reject) => {
        this.jobInternal().then(resolve).catch(reject).finally(rescheduleCb);
      });
    } else {
      return this.jobInternal(true).finally(rescheduleCb);
    }
  }

  cancel() {
    this.#scheduledJob.cancel();
  }

  nextExecution() {
    return this.#scheduledJob.nextInvocation();
  }

  private async jobInternal(rethrow: boolean = false) {
    this.#running = true;
    const instance = this.#factory();
    try {
      return withDb(async () => await instance.run());
    } catch (e) {
      logger.error('Error while running job: %s; %O', instance.taskName, e);
      if (rethrow) throw e;
      return;
    } finally {
      this.#running = false;
      this.lastExecution = new Date();
    }
  }
}
